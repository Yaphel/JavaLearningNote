redis的五种数据结构
	string list（链表） hash  set zset（有序集合，1.集合 2.每个v都有score，利用跳跃表实现）
分布式锁
	用做：多个线程执行中，只有一个线程正在跑。
	但会有超时问题。相对安全的方案是：设一个随机数和过期时间，随机数用做线程自结束，过期时间用做redis定时结束。但此方案仍然不完美。
	分布式锁是一种悲观锁。但也可以使用乐观锁实现：watch
	一种高可用实现：redlock，但是性能要求更高。
用做消息队列
	会有循环读消息的问题，解决方案是：1.消费者线程sleep 2.阻塞读（blpop），但要注意空闲连接的问题。当由于空闲连接断开时，要重连。
hyperloglog
	用来计数的，速度快但有误差，但低于1%
布隆过滤器
	确定某元素是否在集合中，速度快但有误差。（说他存在他可能不存在，但说他不存在一定不存在）
限流：
	简单限流，用zset维护过期时间，每个行为到来的时候，都维护一次时间窗口。
	缺点非常明显，大数据下性能不好。
	漏斗限流，使用到了REDIS模块，redis-cell，然后只要输入参数即可。
redis持久化：
	快照原理：操作系统多进程COW（copy on write）
	AOF：REDIS服务器的指令序列。
	AOF重写：对AOF进行瘦身。
	redis4.0新增混合持久化，将RDB和AOF混合在一起。
管道：
	类似于TCP粘包，将端发送的和接受的信息，一起打包。
事务：
	redis事务只能保证串行化。
redis主从同步：
	全量+增量buffer的形式，因此可能会有一种死循环形式：buffer太小，buffer在增量的过程中被覆盖，导致重新开始全量同步。进而进入死循环。
	另外REDIS只支持最终一致性。
	如果想要redis保证强一致性，需要用到wait（redis3.0）
redis哨兵：
	client先去找哨兵要地址，然后按照地址进行数据服务。
	当主节点挂掉的时候，哨兵负责主从切换。
	当主从切换后，客户端如果进行修改数据操作，从会提示ReadOnlyError，而如果仅仅是读则不会报错。
redis数据库集群分片技术：
	codis
		第三方实现
	redis cluster
		官方实现
	实现原理先空着。
redis stream：
	可支持多播的可持久化消息队列。
redis info：
	可以用于redis诊断问题。
redis过期策略：
	1.定时删除，但是会控制时间，保证会太卡顿。
	2.懒惰删除，查找到key的时候检测过期。
	主从情况下，从节点可能删除的晚一些。
	再设置过期时间的时候，要避免大批量key不在同一时间过期。
